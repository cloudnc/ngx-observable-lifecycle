{"version":3,"sources":["ng://ngx-observable-lifecycle/lib/ivy-api.ts","ng://ngx-observable-lifecycle/lib/ngx-observable-lifecycle.ts"],"names":["hookProp","Symbol","hooksPatched","allHooks","onChanges","onInit","doCheck","afterContentInit","afterContentChecked","afterViewInit","afterViewChecked","onDestroy","getLinkInfo","type","getSubjectForHook","classInstance","hook","hooks","Subject","decorateObservableLifecycle","target","_a","incompatibleComponentError","linkInfo","Object","keys","reduce","patched","originalHook","call","this","next","originalOnDestroy","complete","closeHook","_b","getLifecycleHooks","missingDecoratorError","constructor","Proxy","get","p","asObservable","Error","name"],"mappings":"oRAAO,ICSMA,EAA0BC,OAAO,kCACjCC,EAA8BD,OAAO,4CACrCE,EAA2B,CACtCC,WAAW,EACXC,QAAQ,EACRC,SAAS,EACTC,kBAAkB,EAClBC,qBAAqB,EACrBC,eAAe,EACfC,kBAAkB,EAClBC,WAAW,GAQb,SAASC,EAAkBC,GACzB,OAAQA,ED5BsB,SC4B0BA,ED3B1B,QC2DhC,SAASC,EAAqBC,EAA0CC,GACjED,EAAcf,KACjBe,EAAcf,GAAY,IAG5B,IAAMiB,EAA8BF,EAAcf,GAMlD,OAJKiB,EAAMD,KACRC,EAAMD,GAA0B,IAAIE,EAAAA,SAGhCD,EAAMD,YAWCG,EACdC,EACAC,SAAEJ,EAAAI,EAAAJ,MAAOK,EAAAD,EAAAC,2BAEHC,EAAWX,EAAYQ,GAE7B,IAAKG,EACH,MAAMD,EAGRC,EAASrB,GAAiBsB,OAAOC,KAAKR,GAAmCS,QACvE,SAACC,EAAkCX,GAEjC,GAAIW,EAAQX,GACV,OAAOW,EAGT,IAAMC,EAAeL,EAASP,GAE9BO,EAASP,GAAQ,WACfY,MAAAA,GAAAA,EAAcC,KAAKC,MACnBhB,EAAkBgB,KAAMd,GAAMe,QAGhC,IAAMC,EAAoBT,EAASZ,UAOnC,OANAY,EAASZ,UAAY,WACnBqB,MAAAA,GAAAA,EAAmBH,KAAKC,MAlChC,SAAsBf,EAA0CC,SACjC,QAA7BK,EAAAN,EAAcf,GAAUgB,UAAK,IAAAK,GAAAA,EAAEY,kBACxBlB,EAAcf,GAAUgB,GAiCzBkB,CAAUJ,KAAMd,IAGlBW,EAAQX,IAAQ,EACTW,IAEa,QADrBQ,EACDZ,EAASrB,UAAa,IAAAiC,EAAAA,EAAK,aAYfC,EACdrB,EACAM,OAAEC,EAAAD,EAAAC,2BAA4Be,EAAAhB,EAAAgB,sBAExBd,EAAWX,EAAYG,EAAcuB,aAE3C,IAAKf,EACH,MAAMD,EAGR,IAAKC,EAASrB,GACZ,MAAMmC,EAGR,OAAO,IAAIE,MAAM,GAAyB,CACxCC,IAAA,SAAIpB,EAA2BqB,GAC7B,OAAO3B,EAAkBC,EAAe0B,GAAGC,iDAgBbzB,GAClC,YADkC,IAAAA,IAAAA,EAAAd,GAC3B,SAAAiB,GACL,OAAAD,EAA4BC,EAAQ,CAClCH,MAAKA,EACLK,2BAA4B,IAAIqB,MAC9B,2DAA0DvB,MAAAA,OAAM,EAANA,EAAQwB,MAAI,2JAhBSxB,GACrF,OAAOgB,EAAkBhB,EAAQ,CAC/BiB,sBAAuB,IAAIM,MACzB,6HAEFrB,2BAA4B,IAAIqB,MAC9B,kFAAiFvB,MAAAA,OAAM,EAANA,EAAQkB,YAAYM,MAAI","sourcesContent":["export const NG_COMPONENT_DEF = 'ɵcmp';\nexport const NG_DIRECTIVE_DEF = 'ɵdir';\n","import {\n  ɵComponentDef as ComponentDef,\n  ɵComponentType as ComponentType,\n  ɵDirectiveDef as DirectiveDef,\n  ɵDirectiveType as DirectiveType,\n} from '@angular/core';\nimport { Observable, Subject } from 'rxjs';\nimport { NG_COMPONENT_DEF, NG_DIRECTIVE_DEF } from './ivy-api';\n\nexport const hookProp: unique symbol = Symbol('ngx-observable-lifecycle-hooks');\nexport const hooksPatched: unique symbol = Symbol('ngx-observable-lifecycle-hooks-decorator');\nexport const allHooks: AllHookOptions = {\n  onChanges: true,\n  onInit: true,\n  doCheck: true,\n  afterContentInit: true,\n  afterContentChecked: true,\n  afterViewInit: true,\n  afterViewChecked: true,\n  onDestroy: true,\n};\n\ntype Writeable<T> = { -readonly [P in keyof T]: T[P] };\n\nexport type IvyDirective<T> = Writeable<DirectiveDef<T> | ComponentDef<T>>;\nexport type DecoratedDirective<T, U> = IvyDirective<T> & { [hooksPatched]?: HooksType<U, boolean> };\n\nfunction getLinkInfo<T, U>(type: DirectiveType<T> | ComponentType<T>): DecoratedDirective<T, U> {\n  return (type as ComponentType<T>)[NG_COMPONENT_DEF] || (type as DirectiveType<T>)[NG_DIRECTIVE_DEF];\n}\n\nexport type LifecycleHookKey =\n  | 'onChanges'\n  | 'onInit'\n  | 'doCheck'\n  | 'afterContentInit'\n  | 'afterContentChecked'\n  | 'afterViewInit'\n  | 'afterViewChecked'\n  | 'onDestroy';\n\ntype Hooks<T> = Pick<IvyDirective<T>, LifecycleHookKey>;\n\ntype AllHookOptions = Record<keyof Hooks<any>, true>;\ntype DecorateHookOptions = Partial<AllHookOptions>;\n\nexport type HooksType<T extends DecorateHookOptions, U> = {\n  [P in keyof T]: T[P] extends true ? U : never;\n};\n\nexport type DecoratedHooks<T> = HooksType<T, Observable<void>>;\nexport type DecoratedHooksSub<T> = HooksType<T, Subject<void>>;\n\nexport interface DecorateObservableOptions {\n  hooks: DecorateHookOptions;\n  incompatibleComponentError: Error;\n}\n\ntype DecoratedClassInstance<T> = { [hookProp]: DecoratedHooksSub<T> };\n\nfunction getSubjectForHook<T>(classInstance: DecoratedClassInstance<T>, hook: keyof T): Subject<void> {\n  if (!classInstance[hookProp]) {\n    classInstance[hookProp] = {} as DecoratedClassInstance<T>[typeof hookProp];\n  }\n\n  const hooks: DecoratedHooksSub<T> = classInstance[hookProp];\n\n  if (!hooks[hook]) {\n    (hooks[hook] as Subject<void>) = new Subject<void>();\n  }\n\n  return hooks[hook];\n}\n\nfunction closeHook<T>(classInstance: DecoratedClassInstance<T>, hook: keyof T): void {\n  classInstance[hookProp][hook]?.complete();\n  delete classInstance[hookProp][hook];\n}\n\n/**\n * Library authors should use this to create their own decorators\n */\nexport function decorateObservableLifecycle(\n  target: any,\n  { hooks, incompatibleComponentError }: DecorateObservableOptions,\n): void {\n  const linkInfo = getLinkInfo(target as any);\n\n  if (!linkInfo) {\n    throw incompatibleComponentError;\n  }\n\n  linkInfo[hooksPatched] = (Object.keys(hooks) as Array<LifecycleHookKey>).reduce(\n    (patched: HooksType<any, boolean>, hook) => {\n      // do not re-patch hooks that have already been patched\n      if (patched[hook]) {\n        return patched;\n      }\n\n      const originalHook = linkInfo[hook];\n\n      linkInfo[hook] = function (this: DecoratedClassInstance<any>) {\n        originalHook?.call(this);\n        getSubjectForHook(this, hook).next();\n      };\n\n      const originalOnDestroy = linkInfo.onDestroy;\n      linkInfo.onDestroy = function (this: DecoratedClassInstance<any>) {\n        originalOnDestroy?.call(this);\n        closeHook(this, hook);\n      };\n\n      patched[hook] = true;\n      return patched;\n    },\n    linkInfo[hooksPatched] ?? ({} as HooksType<any, boolean>),\n  );\n}\n\nexport interface GetLifecycleHooksOptions {\n  missingDecoratorError: Error;\n  incompatibleComponentError: Error;\n}\n\n/**\n * Library authors should use this to create their own lifecycle-aware functionality\n */\nexport function getLifecycleHooks<T extends DecorateHookOptions = {}>(\n  classInstance: any,\n  { incompatibleComponentError, missingDecoratorError }: GetLifecycleHooksOptions,\n): DecoratedHooks<T> {\n  const linkInfo = getLinkInfo(classInstance.constructor);\n\n  if (!linkInfo) {\n    throw incompatibleComponentError;\n  }\n\n  if (!linkInfo[hooksPatched]) {\n    throw missingDecoratorError;\n  }\n\n  return new Proxy({} as DecoratedHooks<T>, {\n    get(target: DecoratedHooks<T>, p: keyof T): Observable<void> {\n      return getSubjectForHook(classInstance, p).asObservable();\n    },\n  });\n}\n\nexport function getObservableLifecycle<T extends DecorateHookOptions = AllHookOptions>(target: any): DecoratedHooks<T> {\n  return getLifecycleHooks(target, {\n    missingDecoratorError: new Error(\n      'You must decorate the component or directive with @ObservableLifecycle for getObservableLifecycle to be able to function!',\n    ),\n    incompatibleComponentError: new Error(\n      `You must use getObservableLifecycle with a directive or component. This type (${target?.constructor.name}) is not compatible with getObservableLifecycle!`,\n    ),\n  });\n}\n\nexport function ObservableLifecycle(hooks: DecorateHookOptions = allHooks): ClassDecorator {\n  return target =>\n    decorateObservableLifecycle(target, {\n      hooks,\n      incompatibleComponentError: new Error(\n        `You must decorate a component or directive. This type (${target?.name}) is not compatible with @ObservableLifecycle!`,\n      ),\n    });\n}\n"]}